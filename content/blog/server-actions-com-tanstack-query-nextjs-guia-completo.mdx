---
title: "Server Actions com TanStack Query no Next.js: Um guia completo"
description: "Aprenda como combinar Server Actions com TanStack Query para criar aplica√ß√µes Next.js mais eficientes e type-safe."
date: 2025-08-06
published: true
tags: ["nextjs", "react", "tanstack-query", "server-actions", "typescript", "desenvolvimento"]
---

Os **Server Actions** revolucionaram a forma como lidamos com opera√ß√µes do servidor no Next.js, permitindo executar fun√ß√µes ass√≠ncronas diretamente no servidor. Quando combinados com o **TanStack Query**, temos uma combina√ß√£o poderosa para gerenciamento de estado e cache de dados.

## O que s√£o Server Actions?

**Server Actions** s√£o fun√ß√µes ass√≠ncronas que s√£o executadas no servidor. Voc√™ pode us√°-las em componentes do servidor e do cliente. Elas podem ser utilizadas para submiss√£o de formul√°rios usando `form action` ou em qualquer manipulador de eventos como `onClick`, `onChange`, etc., ou no hook `useEffect`.

Os Server Actions tornaram as coisas mais f√°ceis, seja para buscar dados ou mutar dados diretamente em seus React Server Components.

## React Server Components

**React Server Components** s√£o uma nova forma de construir aplica√ß√µes React renderizadas no servidor. Eles s√£o similares aos componentes React, mas executam no servidor e s√£o renderizados como HTML. Como executam no servidor, podem acessar recursos do lado do servidor como bancos de dados e arquivos. Tamb√©m ajudam a minimizar o tamanho do bundle JS, j√° que os componentes do servidor n√£o s√£o enviados para o cliente.

## Usando Server Actions em Server Components

Voc√™ pode usar server actions diretamente em seu componente do servidor assim:

```typescript
const HomePage = () => {
  // Server Action
  const addUserAction = async (formData: FormData) => {
    'use server';
    const name = formData.get('name');
    console.log(name);
  };
 
  return (
    <form action={addUserAction}>
      <input name="name" />
    </form>
  );
};
 
export default HomePage;
```

Aqui com `'use server'` estamos dizendo ao servidor que esta fun√ß√£o deve ser executada no servidor. Mas e quanto aos componentes do cliente?

## Server Actions em Client Components

Para usar server actions em componentes do cliente, temos que criar um novo arquivo e marc√°-lo para executar no servidor adicionando `'use server'` no topo do arquivo:

```typescript
// action.ts
 
'use server';
 
export const addUserAction = async (formData: FormData) => {
  'use server';
  const name = formData.get('name');
  console.log(name);
};
 
// Agora voc√™ pode usar esta action no componente cliente assim:
 
// client.tsx
import { addUserAction } from './action';
 
const ClientPage = () => {
  return (
    <form action={addUserAction}>
      <input name="name" />
    </form>
  );
};
```

## Como usar Server Actions para buscar dados com TanStack Query

O **TanStack Query** √© uma biblioteca poderosa para busca e cache de dados para React. √â parte do TanStack, uma cole√ß√£o de bibliotecas que ajudam voc√™ a construir aplica√ß√µes React full-stack. Ela fornece um conjunto de hooks e utilit√°rios para buscar e cachear dados em seus componentes React.

Agora que sabemos que buscar dados com server components √© f√°cil, mas e quanto aos componentes do cliente? Bem, com TanStack Query podemos torn√°-lo mais intuitivo e f√°cil de usar com type safety de ponta a ponta.

<Callout type="warning">
**Importante**: √â recomendado usar Server Actions para muta√ß√µes de dados apenas, n√£o para busca de dados. Estou aqui compartilhando uma forma como podemos usar server actions para buscar dados tamb√©m com TanStack Query.
</Callout>

Mas e se pudermos usar server component para buscar dados iniciais e passar para tanstack query e usar server action para refazer a busca? Soa bem, certo?

```typescript
// app/page.tsx
 
import Post from '@/components/post';
 
export type TPost = {
  userId: number;
  id: number;
  title: string;
  body: string;
};
 
export const getAllPost = async (): Promise<TPost[]> => {
  const response = await fetch(`https://jsonplaceholder.typicode.com/posts`);
  const data = await response.json();
  return data;
};
 
const HomePage = async () => {
  const post = await getAllPost();
  return <Post post={post} />;
};
 
export default HomePage;
```

Aqui como voc√™ pode ver, estamos buscando os dados no server component e passando para o componente cliente. Agora podemos pass√°-lo para o Tanstack query como dados iniciais e usar server action para refazer a busca.

```typescript
// components/post.tsx
 
'use client';
 
import { useQuery } from '@tanstack/react-query';
import { postAction } from './action/post-action';
import { TPost } from '@/app/page';
 
const Post = ({ post }: { post: TPost[] }) => {
  const { data, isLoading, refetch } = useQuery({
    queryKey: [`post`],
    queryFn: async () => {
      const data = await postAction();
      return data;
    },
    initialData: post,
    refetchOnMount: false,
  });
 
  return (
    <main>
      <h1>Post</h1>
      {isLoading ? (
        <p>Loading...</p>
      ) : (
        <ul>
          {data?.map((post) => (
            <li key={post.id}>
              <h2>{post.title}</h2>
              <p>{post.body}</p>
            </li>
          ))}
        </ul>
      )}
 
      <button onClick={() => refetch()}>Refresh</button>
    </main>
  );
};
 
export default Post;
```

Aqui estamos usando Tanstack query para buscar os dados e usando server action para refazer a busca. A coisa importante a notar aqui √© que temos que manter `refetchOnMount` como `false` para evitar refazer a busca no mount, j√° que j√° passamos os dados iniciais que buscamos no server component.

Agora sobre nosso arquivo de server action:

```typescript
// action/post-action.ts
 
'use server';
 
import { getAllPost, TPost } from '@/app/page';
 
export const postAction = async (): Promise<TPost[]> => {
  const posts = await getAllPost();
  return posts.slice(0, 5);
};
```

Simplesmente criamos um arquivo `post-action.ts` e marcamos como arquivo do servidor e criamos uma fun√ß√£o para buscar os dados e retorn√°-los. Agora podemos usar esta fun√ß√£o em nosso componente cliente para refazer a busca. Para fins de teste, estamos retornando apenas 5 posts. E a parte mais importante √© que estamos reutilizando a mesma fun√ß√£o que usamos no server component para buscar os dados.

Obviamente, sempre √© bom buscar dados no server component e passar para o componente cliente e na muta√ß√£o podemos revalidar usando as fun√ß√µes fornecidas pelo Next.js `revalidatePath` e `revalidateTag`. Podemos usar a nova API `cache` do React para lidar com a busca de dados para o pr√≥ximo n√≠vel em React Server Components.

## Muta√ß√£o usando Server Action com TanStack Query

Mutamos dados em nossa aplica√ß√£o em m√∫ltiplos lugares e queremos dar ao usu√°rio uma boa experi√™ncia com valida√ß√£o do lado do cliente para resposta r√°pida e estado de loading para tarefas em andamento e erro mostrado se o servidor retornar erro. Podemos fazer tudo isso manualmente, mas √© aqui que o TanStack Query brilha e gerencia tudo automaticamente.

```typescript
// components/post-mutation.tsx
 
'use client';
 
import { useMutation } from '@tanstack/react-query';
import { postMutationAction } from './action/postMutation-action';
 
const PostMutation = () => {
  const { data, mutate, isPending } = useMutation({
    mutationFn: postMutationAction,
    onError: (error) => {
      return alert(error.message || 'Falha ao atualizar');
    },
    onSuccess: () => {
      // revalidar dados ou mostrar toast de sucesso
    },
  });
 
  return (
    <div>
      <h1>Post Mutation</h1>
      <button onClick={() => mutate({ title: 'foo', body: 'bar', userId: 1 })}>
        Post
      </button>
      {isPending ? <p>pending...</p> : null}
      {data ? <p>{JSON.stringify(data)}</p> : null}
    </div>
  );
};
 
export default PostMutation;
```

Aqui como voc√™ pode ver, passamos nossa fun√ß√£o de muta√ß√£o do server action para o `mutationFn` do TanStack e depois disso estamos lidando com todos os outros estados para uma resposta. E isso √© totalmente type-safe de ponta a ponta. O TanStack fornece a fun√ß√£o `mutate` que podemos usar para disparar a muta√ß√£o e se precisarmos passar esses dados no caso de nosso server action precisar aqui, podemos simplesmente passar aqui de forma type-safe.

```typescript
// postMutation-action.ts
 
'use server';
 
type TParams = {
  title: string;
  body: string;
  userId: number;
};
 
type TPost = TParams & {
  id: number;
};
 
export const postMutationAction = async (params: TParams): Promise<TPost> => {
  const response = await fetch(`https://jsonplaceholder.typicode.com/posts`, {
    method: 'POST',
    body: JSON.stringify(params),
    headers: {
      'Content-type': 'application/json; charset=UTF-8',
    },
  });
  const data = await response.json();
  return data;
};
```

Aqui estamos simplesmente criando um arquivo de server action e passando os dados para o servidor e retornando a resposta. E estamos usando esta fun√ß√£o em nosso componente cliente para mutar os dados.

Como voc√™ pode ver, qu√£o f√°cil √© usar server action com TanStack Query para buscar e mutar dados em sua aplica√ß√£o. A coisa boa aqui √© que estamos obtendo benef√≠cios de ambos os lados, onde server actions nos d√£o poder onde n√£o precisamos criar rotas de API e com TanStack podemos obter todo o gerenciamento de estado e cache automaticamente.

## Benef√≠cios da Combina√ß√£o

### 1. **Type Safety Completo**

```typescript
// Exemplo de type safety entre Server Actions e TanStack Query
type User = {
  id: number;
  name: string;
  email: string;
};

// Server Action com tipos
const createUserAction = async (userData: Omit<User, 'id'>): Promise<User> => {
  'use server';
  // L√≥gica de cria√ß√£o
  return { id: 1, ...userData };
};

// TanStack Query com os mesmos tipos
const { mutate } = useMutation({
  mutationFn: createUserAction, // TypeScript infere os tipos automaticamente
});
```

### 2. **Cache Inteligente**

```typescript
const { data, refetch } = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsersAction,
  initialData: serverUsers, // Dados do servidor como cache inicial
  staleTime: 5 * 60 * 1000, // 5 minutos
});
```

### 3. **Otimiza√ß√£o de Performance**

```typescript
// Server Component busca dados iniciais
const HomePage = async () => {
  const initialData = await fetchInitialData();
  
  return (
    <ClientComponent 
      initialData={initialData}
      // TanStack Query usa os dados iniciais como cache
    />
  );
};
```

## Casos de Uso Pr√°ticos

### Formul√°rios com Valida√ß√£o

```typescript
// action.ts
'use server';

import { z } from 'zod';

const UserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

export const createUserAction = async (formData: FormData) => {
  const data = Object.fromEntries(formData);
  const validatedData = UserSchema.parse(data);
  
  // Criar usu√°rio no banco
  return { success: true, user: validatedData };
};

// Component.tsx
'use client';

import { useMutation } from '@tanstack/react-query';

const UserForm = () => {
  const { mutate, isPending } = useMutation({
    mutationFn: createUserAction,
    onSuccess: () => {
      // Revalidar cache ou mostrar sucesso
    },
  });

  return (
    <form action={mutate}>
      <input name="name" required />
      <input name="email" type="email" required />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Criando...' : 'Criar Usu√°rio'}
      </button>
    </form>
  );
};
```

### Lista com Pagina√ß√£o

```typescript
// Server Component
const UsersPage = async ({ searchParams }: { searchParams: { page?: string } }) => {
  const page = parseInt(searchParams.page || '1');
  const initialUsers = await fetchUsers(page);
  
  return <UsersList initialData={initialUsers} currentPage={page} />;
};

// Client Component
const UsersList = ({ initialData, currentPage }: Props) => {
  const { data, isLoading } = useQuery({
    queryKey: ['users', currentPage],
    queryFn: () => fetchUsersAction(currentPage),
    initialData,
  });

  return (
    <div>
      {data?.map(user => <UserCard key={user.id} user={user} />)}
      <Pagination currentPage={currentPage} />
    </div>
  );
};
```

## Boas Pr√°ticas

### 1. **Separa√ß√£o de Responsabilidades**

```typescript
// actions/data-actions.ts
'use server';

export const fetchUsersAction = async (page: number) => {
  // L√≥gica de busca
};

export const createUserAction = async (userData: UserData) => {
  // L√≥gica de cria√ß√£o
};

// hooks/useUsers.ts
export const useUsers = (page: number, initialData?: User[]) => {
  return useQuery({
    queryKey: ['users', page],
    queryFn: () => fetchUsersAction(page),
    initialData,
  });
};
```

### 2. **Tratamento de Erros**

```typescript
const { mutate, error } = useMutation({
  mutationFn: createUserAction,
  onError: (error) => {
    if (error instanceof Error) {
      toast.error(error.message);
    }
  },
});
```

### 3. **Otimiza√ß√£o de Cache**

```typescript
const queryClient = useQueryClient();

const { mutate } = useMutation({
  mutationFn: createUserAction,
  onSuccess: (newUser) => {
    // Atualizar cache otimisticamente
    queryClient.setQueryData(['users'], (old: User[] = []) => [
      ...old,
      newUser
    ]);
  },
});
```

## Conclus√£o

React Server Components √© um novo paradigma que nos ajuda a renderizar algumas partes de nossa aplica√ß√£o diretamente no servidor e enviar o HTML para o cliente, ap√≥s isso o React hidrata e torna interativo. Server Actions levaram isso para o pr√≥ximo n√≠vel onde podemos usar server actions para buscar dados e mutar dados diretamente em nossos server components.

TanStack Query e Server Actions s√£o duas ferramentas poderosas que podem ser usadas juntas para tornar nossa aplica√ß√£o mais intuitiva e f√°cil de usar. Com TanStack Query podemos buscar e cachear dados em nossa aplica√ß√£o e com Server Actions podemos mutar dados e buscar dados em nossos server components.

<Callout type="info">
**Dica**: Comece usando Server Actions para muta√ß√µes simples e gradualmente adicione TanStack Query para gerenciamento de cache mais complexo. A combina√ß√£o oferece o melhor dos dois mundos: performance do servidor e experi√™ncia rica do cliente.
</Callout>

---

Espero que este guia tenha ajudado voc√™ a entender como usar Server Actions com TanStack Query no Next.js. At√© a pr√≥xima! üöÄ 