---
title: "Zustand + React Query: O Duo Perfeito para Gerenciamento de Estado em React"
description: "Descubra como combinar Zustand e React Query para criar uma arquitetura de estado eficiente, leve e fÃ¡cil de manter em suas aplicaÃ§Ãµes React."
date: 2025-08-11
published: true
tags: ["react", "zustand", "react-query", "typescript", "desenvolvimento", "frontend"]
---

O gerenciamento de estado em aplicaÃ§Ãµes React sempre foi um desafio constante para desenvolvedores. Com o passar dos anos, vimos o surgimento de vÃ¡rias soluÃ§Ãµes: Redux com sua arquitetura robusta, Context API nativa do React, MobX com sua reatividade automÃ¡tica, e muitas outras. Mas recentemente, uma combinaÃ§Ã£o especÃ­fica tem chamado atenÃ§Ã£o pela simplicidade e eficiÃªncia: **Zustand** + **React Query**.

Esta dupla oferece uma abordagem moderna e pragmÃ¡tica para lidar com os dois tipos principais de estado em aplicaÃ§Ãµes web: **estado do cliente** (Zustand) e **estado do servidor** (React Query).

## Por que Zustand?

Zustand Ã© uma biblioteca de gerenciamento de estado que prioriza a simplicidade sem sacrificar a funcionalidade. Diferente de outras soluÃ§Ãµes, ele nÃ£o impÃµe uma arquitetura especÃ­fica - vocÃª define suas prÃ³prias regras.

### CaracterÃ­sticas principais:

* **Bundle size mÃ­nimo** â€” Apenas ~2KB gzipped
* **Zero configuraÃ§Ã£o** â€” Funciona imediatamente apÃ³s a instalaÃ§Ã£o
* **API intuitiva** â€” Baseada em hooks nativos do React
* **TypeScript nativo** â€” InferÃªncia de tipos automÃ¡tica

### Exemplo bÃ¡sico:

```typescript
import { create } from "zustand";

interface CounterStore {
  count: number;
  increment: () => void;
  decrement: () => void;
}

const useCounterStore = create<CounterStore>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

// Uso no componente
function Counter() {
  const { count, increment, decrement } = useCounterStore();
  
  return (
    <div>
      <h2>Contador: {count}</h2>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

## SeparaÃ§Ã£o de Responsabilidades

A chave para uma arquitetura de estado eficiente Ã© entender que **estado do cliente** e **estado do servidor** sÃ£o fundamentalmente diferentes:

### Estado do Cliente (Zustand)
- PreferÃªncias do usuÃ¡rio
- Estado da interface (modais, sidebar, formulÃ¡rios)
- Dados temporÃ¡rios de sessÃ£o

### Estado do Servidor (React Query)
- Dados vindos de APIs
- Cache de informaÃ§Ãµes
- SincronizaÃ§Ã£o em background

## Exemplo PrÃ¡tico: Sistema de Blog

Vamos criar um exemplo prÃ¡tico de como usar ambas as ferramentas juntas:

### 1. Store Zustand para Estado da UI

```typescript
interface BlogUIStore {
  sidebar: { isOpen: boolean };
  selectedPostId: string | null;
  toggleSidebar: () => void;
  selectPost: (id: string | null) => void;
}

const useBlogUIStore = create<BlogUIStore>((set) => ({
  sidebar: { isOpen: false },
  selectedPostId: null,
  toggleSidebar: () => set((state) => ({ 
    sidebar: { isOpen: !state.sidebar.isOpen } 
  })),
  selectPost: (id) => set({ selectedPostId: id }),
}));
```

### 2. React Query para Dados do Servidor

```typescript
import { useQuery } from '@tanstack/react-query';

export const usePosts = () => {
  return useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    staleTime: 5 * 60 * 1000, // 5 minutos
  });
};

export const usePost = (id: string) => {
  return useQuery({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    enabled: !!id,
  });
};
```

### 3. Componente que Integra Ambos

```typescript
function BlogDashboard() {
  const { data: posts, isLoading } = usePosts();
  const { selectedPostId, selectPost } = useBlogUIStore();
  const { data: selectedPost } = usePost(selectedPostId);
  
  if (isLoading) return <div>Carregando posts...</div>;
  
  return (
    <div className="blog-dashboard">
      <div className="posts-list">
        {posts?.map((post) => (
          <div 
            key={post.id}
            onClick={() => selectPost(post.id)}
            className={selectedPostId === post.id ? 'selected' : ''}
          >
            <h3>{post.title}</h3>
            <p>{post.excerpt}</p>
          </div>
        ))}
      </div>
      
      {selectedPost && (
        <div className="post-detail">
          <h2>{selectedPost.title}</h2>
          <p>{selectedPost.content}</p>
        </div>
      )}
    </div>
  );
}
```

## OrganizaÃ§Ã£o de Stores

### Stores por DomÃ­nio

Em vez de uma store gigante, divida por domÃ­nios de negÃ³cio:

```typescript
// stores/auth.ts
export const useAuthStore = create((set) => ({
  user: null,
  isAuthenticated: false,
  login: (user) => set({ user, isAuthenticated: true }),
  logout: () => set({ user: null, isAuthenticated: false }),
}));

// stores/ui.ts
export const useUIStore = create((set) => ({
  theme: 'light',
  toggleTheme: () => set((state) => ({ 
    theme: state.theme === 'light' ? 'dark' : 'light' 
  })),
}));
```

## OtimizaÃ§Ãµes de Performance

### Seletores Granulares

```typescript
// âŒ Ruim: Componente re-renderiza sempre
const { user, isAuthenticated } = useAuthStore();

// âœ… Bom: Apenas quando necessÃ¡rio
const user = useAuthStore((state) => state.user);
const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
```

### Middleware de PersistÃªncia

```typescript
import { persist } from 'zustand/middleware';

const usePersistedStore = create(
  persist(
    (set) => ({
      preferences: { theme: 'light', language: 'pt-BR' },
      updatePreference: (key, value) => 
        set((state) => ({
          preferences: { ...state.preferences, [key]: value }
        })),
    }),
    { name: 'user-preferences' }
  )
);
```

## MigraÃ§Ã£o de Redux

Se vocÃª tem uma aplicaÃ§Ã£o Redux existente, a migraÃ§Ã£o pode ser feita gradualmente:

### Fase 1: Adicione Zustand para Novas Funcionalidades
### Fase 2: Migre Stores Simples
### Fase 3: Substitua Redux por React Query + Zustand

## Estrutura Recomendada

```
src/
â”œâ”€â”€ stores/
â”‚   â”œâ”€â”€ auth.ts
â”‚   â”œâ”€â”€ ui.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ queries/
â”‚   â””â”€â”€ mutations/
â””â”€â”€ components/
```

## ConclusÃ£o

A combinaÃ§Ã£o de Zustand e React Query representa uma evoluÃ§Ã£o natural no ecossistema React. Juntos, eles oferecem:

- **Simplicidade** sem perda de funcionalidade
- **Performance** otimizada com re-renders mÃ­nimos
- **Manutenibilidade** com cÃ³digo limpo e organizado
- **Escalabilidade** para aplicaÃ§Ãµes de qualquer tamanho

Esta arquitetura Ã© especialmente adequada para equipes que valorizam cÃ³digo limpo, performance e manutenibilidade a longo prazo.

<Callout type="info">
**Dica**: Comece implementando Zustand para funcionalidades simples como tema, sidebar ou modais. Depois evolua para gerenciar estado mais complexo.
</Callout>

<Callout type="warning">
**Importante**: O React Query foi renomeado para TanStack Query. Para projetos novos, use `@tanstack/react-query`.
</Callout>

---

**ReferÃªncia**: Este artigo foi inspirado no conteÃºdo de [Zustand Meets React Query: The Perfect Pair for State Handling](https://levelup.gitconnected.com/zustand-react-query-the-lightweight-duo-for-state-management-271c5454a956) por Chamith Madusanka, mas foi completamente reescrito e expandido com exemplos prÃ¡ticos e casos de uso reais.

Espero que este guia prÃ¡tico tenha ajudado vocÃª a entender como implementar Zustand e React Query em suas aplicaÃ§Ãµes React. AtÃ© a prÃ³xima! ðŸš€
